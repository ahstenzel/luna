#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <filesystem>
#include <ctime>
#include <cstdint>
#include <libbase64.h>
#include <vex/vex_cpp.hpp>
#include <nlohmann/json.hpp>
using json = nlohmann::json;

static std::filesystem::path file_alternate_extension(const std::filesystem::path& path, const std::string& ext) {
	if (path.extension() == ext) { return path; }
	std::filesystem::path alternate_path = path.parent_path();
	alternate_path /= path.stem();
	return std::filesystem::path(alternate_path.string() + ext);
}

int main(int argc, char** argv) {
	// Get current time
	time_t timer = time(nullptr);
	struct tm* tm_info = localtime(&timer);
	char time_buffer[32] = "\0";
	strftime(time_buffer, 32, "%c", tm_info);

	// Read arguments
	vex parser(
		"headerencoder",
		"1.0",
		"Encodes shader files into base64 and packs them into a C++ source file."
	);
	parser.add_arg("Input files", VEX_ARG_TYPE_STR, "input", 'i');
	parser.add_arg("Output files", VEX_ARG_TYPE_STR, "output", 'o', 1);
	parser.add_arg("Seperate header & source output", VEX_ARG_TYPE_FLAG, "seperate", 's');
	parser.parse(argc, argv);
	if (parser.arg_found("h")) {
		std::cout << parser.get_help() << std::endl;
		return 0;
	}
	if (parser.arg_found("v")) {
		std::cout << parser.get_version() << std::endl;
		return 0;
	}
	bool seperate_output = parser.arg_found("s");
	std::vector<std::string> input_file_names;
	std::string output_file_name;
	for (auto& token : parser) {
		if (token.short_name == 'i') {
			for (int i = 0; i < token.arg_count; ++i) {
				input_file_names.emplace_back(token.arg[i].str_arg);
			}
		}
		else if (token.short_name == 'o') {
			output_file_name = std::string(token.arg[0].str_arg);
		}
	}

	// Validate
	if (input_file_names.empty()) {
		std::cerr << "No input files specified" << std::endl;
		return 1;
	}
	if (output_file_name.empty()) {
		output_file_name = "shader_encoded";
	}
	else {
		output_file_name = file_alternate_extension(output_file_name, "").string();
	}

	// Write output file
	std::string output_header_file_name = output_file_name + ".hpp";
	std::string output_source_file_name = output_file_name + ".cpp";
	std::ofstream output_header_file;
	std::ofstream output_source_file;
	output_header_file.open(output_header_file_name, std::ios::out | std::ios::trunc);
	if (output_header_file.fail()) {
		std::cerr << "Failed to open output file (" << output_header_file_name << ")" << std::endl;
		return 1;
	}
	output_header_file
		<< "// The following file has been auto-generated by headerencoder, modifying it may have unintended consequences." << std::endl
		<< "// Generation date: " << time_buffer << std::endl
		<< "#pragma once" << std::endl
		<< "#include <string>" << std::endl
		<< "struct ShaderInfo {" << std::endl
		<< "\tstd::string m_name;" << std::endl
		<< "\tstd::string m_source;" << std::endl
		<< "\tstd::int32_t m_samplers;" << std::endl
		<< "\tstd::int32_t m_storageTextures;" << std::endl
		<< "\tstd::int32_t m_storageBuffers;" << std::endl
		<< "\tstd::int32_t m_uniformBuffers;" << std::endl
		<< "};" << std::endl;
	if (seperate_output) {
		output_source_file.open(output_source_file_name, std::ios::out | std::ios::trunc);
		if (output_source_file.fail()) {
			std::cerr << "Failed to open output file (" << output_source_file_name << ")" << std::endl;
			return 1;
		}
		output_source_file << "#include " << std::filesystem::path(output_header_file_name).filename() << "" << std::endl;
	}
	for (auto& input_file_name : input_file_names) {
		std::cout << "Reading file (" << input_file_name << ")..." << std::endl;

		// Read file contents
		std::filesystem::path input_file_path(input_file_name);
		std::ifstream input_file;
		input_file.open(input_file_name, std::ios::in);
		if (input_file.fail()) {
			std::cerr << "Failed to open input file (" << input_file_name << ")";
			return 1;
		}
		std::size_t file_size = std::filesystem::file_size(input_file_path);
		std::string file_contents;
		file_contents.resize(file_size);
		input_file.read(file_contents.data(), file_size);
		input_file.close();

		// Convert to base64
		std::size_t encoded_size = 0;
		std::size_t buffer_size = (((4 * file_size / 3) + 3) & ~3);
		std::string encoded;
		encoded.resize(buffer_size);
		base64_encode(file_contents.c_str(), file_size, encoded.data(), &encoded_size, 0);

		// Construct variable name
		std::string var_name = input_file_path.filename().string();
		for (auto& c : var_name) {
			if (c == ' ' || c == '.') { c = '_'; }
		}

		// Check for metadata file
		std::filesystem::path meta_file_path = file_alternate_extension(input_file_path, ".json");
		std::string meta_file_name = meta_file_path.string();
		json meta_data;
		if (std::filesystem::exists(meta_file_path)) {
			std::ifstream meta_file;
			meta_file.open(meta_file_name, std::ios::in);
			if (meta_file.fail()) {
				std::cerr << "Failed to open metadata file (" << meta_file_name << ")" << std::endl;
				output_header_file.close();
				if (seperate_output) { output_source_file.close(); }
				return 1;
			}
			meta_data = json::parse(meta_file);
		}
		else {
			std::cout << "No metadata file found at (" << meta_file_name << ")" << std::endl;
		}

		// Write to output file
		if (seperate_output) {
			output_header_file << "extern const ShaderInfo " << var_name << ";" << std::endl;
			output_source_file
				<< "const ShaderInfo " << var_name << " = {" << std::endl
				<< "\t\"" << var_name << "\"," << std::endl
				<< "\t\"" << encoded << "\"," << std::endl
				<< "\t" << ((meta_data.contains("samplers")) ? meta_data["samplers"] : -1) << "," << std::endl
				<< "\t" << ((meta_data.contains("storage_textures")) ? meta_data["storage_textures"] : -1) << "," << std::endl
				<< "\t" << ((meta_data.contains("storage_buffers")) ? meta_data["storage_buffers"] : -1) << "," << std::endl
				<< "\t" << ((meta_data.contains("uniform_buffers")) ? meta_data["uniform_buffers"] : -1) << std::endl
				<< "};" << std::endl;
		}
		else {
			output_header_file
				<< "const ShaderInfo " << var_name << " = {" << std::endl
				<< "\t\"" << var_name << "\"," << std::endl
				<< "\t\"" << encoded << "\"," << std::endl
				<< "\t" << ((meta_data.contains("samplers")) ? meta_data["samplers"] : -1) << "," << std::endl
				<< "\t" << ((meta_data.contains("storage_textures")) ? meta_data["storage_textures"] : -1) << "," << std::endl
				<< "\t" << ((meta_data.contains("storage_buffers")) ? meta_data["storage_buffers"] : -1) << "," << std::endl
				<< "\t" << ((meta_data.contains("uniform_buffers")) ? meta_data["uniform_buffers"] : -1) << std::endl
				<< "};" << std::endl;
		}
	}
	output_header_file.close();
	output_source_file.close();
	return 0;
}